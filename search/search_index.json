{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>      View on GitHub    </p> <p>Scarf (short for Self-Contained Application Refactoring) benchmark is a suite of Java applications across frameworks: Jakarta EE, Quarkus, and Spring for evaluating agentic transformation between the frameworks. This suite enables systematic assessment of AI agents' ability to migrate enterprise Java applications while preserving functionality, idiomatic patterns, and architectural integrity across different runtime environments.</p> <p>The benchmark includes comprehensive examples ranging from focused layer-specific demonstrations to complete production-grade applications, each with verified implementations across all supported frameworks.</p> <p>Manual Conversions with Developer Verification</p> <p>All applications in this benchmark have been manually converted and verified by experienced developers. Each implementation has undergone rigorous testing to ensure functional correctness, adherence to framework-specific idioms, and preservation of architectural integrity across Jakarta EE, Quarkus, and Spring frameworks.</p>"},{"location":"#getting-started-with-the-scarf-benchmark","title":"Getting Started with the Scarf Benchmark","text":"<ul> <li>Quickstart</li> </ul> <ul> <li> <p>Leaderboard     ---</p> <p>Run through an example to quickly set up Scarfbench and evaluate agentic solutions.</p> </li> <li> <p>Leaderboard</p> <p>Compare AI agents and transformation tools on the benchmark suite. Track performance metrics and identify best practices for automated application migration.</p> </li> </ul>"},{"location":"#benchmark-applications","title":"Benchmark Applications","text":"<p>This benchmark contains self-contained applications demonstrating core Java EE functionalities and their framework-specific implementations. Each example has been manually converted and verified across all target frameworks, with smoke tests included to verify application behavior after transformation.</p> <p>The benchmark includes two types of examples:</p>"},{"location":"#focused-examples","title":"Focused Examples","text":"<p>Application examples organized per layer, where each example demonstrates a specific technology within that layer (e.g., persistence, presentation, integration).</p> <ul> <li> <p>Business Domain Layer</p> <p>Core business logic implementations using Enterprise JavaBeans (EJBs). Demonstrates stateful, stateless, and singleton session beans for shopping carts, currency conversion, hit counters, web services, and standalone EJB usage.</p> </li> <li> <p>Dependency Injection Layer</p> <p>CDI and dependency injection patterns including custom qualifiers, interceptors, decorators, producer methods, event observers, and alternative implementations for conditional bean selection.</p> </li> <li> <p>Infrastructure Layer</p> <p>Enterprise features including managed executors for concurrency, asynchronous EJB methods, interceptors for cross-cutting concerns, and timer services for scheduled task execution.</p> </li> <li> <p>Integration Layer</p> <p>Integration technologies featuring Jakarta Batch processing, JMS messaging patterns, message-driven beans, JAX-WS web services, and Java Connector Architecture for enterprise system integration.</p> </li> <li> <p>Persistence Layer</p> <p>Data persistence patterns using JPA entities with CRUD operations, complex entity relationships, composite keys, inheritance strategies, and JPQL queries for database interactions.</p> </li> <li> <p>Presentation Layer</p> <p>Web tier implementations including servlets, JAX-RS REST APIs, WebSocket endpoints, server-sent events, file uploads, filters, listeners, and real-time communication patterns.</p> </li> <li> <p>Security Layer</p> <p>Authentication and authorization patterns featuring Jakarta Security identity stores, form-based and basic authentication, EJB security, role-based access control, and password hashing.</p> </li> </ul>"},{"location":"#whole-applications","title":"Whole Applications","text":"<p>Complete, functioning applications that demonstrate the coordination and interaction between multiple layers.</p> <ul> <li> <p>CargoTracker</p> <p>Domain-Driven Design cargo shipping tracker with Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, and JMS. Showcases aggregates, repositories, and domain events following Eric Evans' DDD patterns.</p> </li> <li> <p>Coffee Shop</p> <p>Event-driven microservices with Orders, Barista, and Kitchen services via Kafka. Demonstrates MicroProfile stack, reactive messaging, distributed transactions, and eventual consistency.</p> </li> <li> <p>DayTrader</p> <p>High-performance stock trading benchmark with stateless session beans, JPA optimistic locking, transaction management, and connection pooling. Used for measuring server performance.</p> </li> <li> <p>PetClinic</p> <p>Veterinary clinic management with Jakarta Faces (PrimeFaces), complex JPA relationships, CDI, and Bean Validation. Complete workflows for owners, pets, visits, and veterinarians.</p> </li> <li> <p>RealWorld</p> <p>Medium.com clone with MicroProfile JWT, JAX-RS REST API, article management, comments, favorites, tags, and user following. Includes Testcontainers integration tests.</p> </li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>ScarfBench is actively maintained and continuously evolving to support the research community. We are committed to expanding the benchmark's capabilities and improving its utility for evaluating AI-driven application transformation. Here's what's coming:</p> <ul> <li> <p>Comprehensive Smoke Tests</p> <p>We are developing an extensive suite of automated smoke tests to validate functional equivalence across framework migrations. These tests will ensure that transformed applications maintain their original behavior, catching subtle regressions and framework-specific issues that may arise during migration.</p> </li> <li> <p>Dynamic Leaderboard</p> <p>A live leaderboard will track and compare the performance of different AI agents and transformation tools across the benchmark suite. This will provide transparent, reproducible metrics for the research community and help identify best practices in automated application migration.</p> </li> <li> <p>Rich Taxonomy of Errors</p> <p>We are building a comprehensive taxonomy that categorizes transformation errors, anti-patterns, and common pitfalls. This taxonomy will help researchers understand where current approaches struggle and guide development of more robust transformation strategies.</p> </li> </ul> <p>ScarfBench will continue to receive regular updates with new applications, enhanced documentation, and improved tooling. We welcome community contributions and feedback to make this benchmark more valuable for advancing the state of automated application transformation.</p>"},{"location":"#contact","title":"Contact","text":"<p>For any questions, feedback, or suggestions, please contact the authors:</p> Name Email Rahul Krishna i.m.ralk@gmail.com Raju Pavuluri pavuluri@us.ibm.com"},{"location":"benchmark/","title":"Benchmark","text":"<p>Scarf is a benchmark suite for evaluating agentic transformation of Java applications across frameworks: Jakarta EE, Quarkus, and Spring. This suite enables systematic assessment of AI agents' ability to migrate enterprise Java applications while preserving functionality, idiomatic patterns, and architectural integrity across different runtime environments.</p> <p>This benchmark contains self-contained applications demonstrating core Java EE functionalities and their framework-specific implementations. Each example has been manually converted and verified across all target frameworks, with smoke tests included to verify application behavior after transformation.</p> <p>The benchmark includes two types of examples:</p> <ol> <li>Focused examples - Application examples organized per layer, where each example demonstrates a specific technology within that layer (e.g., persistence, presentation, integration).</li> <li>Whole applications - Complete, functioning applications that demonstrate the coordination and interaction between multiple layers.</li> </ol>"},{"location":"benchmark/#focused-examples","title":"Focused Examples","text":"<p>Application examples organized per layer, where each example demonstrates a specific technology within that layer (e.g., persistence, presentation, integration).</p> <ul> <li> <p>Business Domain Layer</p> <p>Core business logic implementations using Enterprise JavaBeans (EJBs). Demonstrates stateful, stateless, and singleton session beans for shopping carts, currency conversion, hit counters, web services, and standalone EJB usage.</p> </li> <li> <p>Dependency Injection Layer</p> <p>CDI and dependency injection patterns including custom qualifiers, interceptors, decorators, producer methods, event observers, and alternative implementations for conditional bean selection.</p> </li> <li> <p>Infrastructure Layer</p> <p>Enterprise features including managed executors for concurrency, asynchronous EJB methods, interceptors for cross-cutting concerns, and timer services for scheduled task execution.</p> </li> <li> <p>Integration Layer</p> <p>Integration technologies featuring Jakarta Batch processing, JMS messaging patterns, message-driven beans, JAX-WS web services, and Java Connector Architecture for enterprise system integration.</p> </li> <li> <p>Persistence Layer</p> <p>Data persistence patterns using JPA entities with CRUD operations, complex entity relationships, composite keys, inheritance strategies, and JPQL queries for database interactions.</p> </li> <li> <p>Presentation Layer</p> <p>Web tier implementations including servlets, JAX-RS REST APIs, WebSocket endpoints, server-sent events, file uploads, filters, listeners, and real-time communication patterns.</p> </li> <li> <p>Security Layer</p> <p>Authentication and authorization patterns featuring Jakarta Security identity stores, form-based and basic authentication, EJB security, role-based access control, and password hashing.</p> </li> </ul>"},{"location":"benchmark/#whole-applications","title":"Whole Applications","text":"<p>Complete, functioning applications that demonstrate the coordination and interaction between multiple layers.</p> <ul> <li> <p>CargoTracker</p> <p>Domain-Driven Design cargo shipping tracker with Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, and JMS. Showcases aggregates, repositories, and domain events following Eric Evans' DDD patterns.</p> </li> <li> <p>Coffee Shop</p> <p>Event-driven microservices with Orders, Barista, and Kitchen services via Kafka. Demonstrates MicroProfile stack, reactive messaging, distributed transactions, and eventual consistency.</p> </li> <li> <p>DayTrader</p> <p>High-performance stock trading benchmark with stateless session beans, JPA optimistic locking, transaction management, and connection pooling. Used for measuring server performance.</p> </li> <li> <p>PetClinic</p> <p>Veterinary clinic management with Jakarta Faces (PrimeFaces), complex JPA relationships, CDI, and Bean Validation. Complete workflows for owners, pets, visits, and veterinarians.</p> </li> <li> <p>RealWorld</p> <p>Medium.com clone with MicroProfile JWT, JAX-RS REST API, article management, comments, favorites, tags, and user following. Includes Testcontainers integration tests.</p> </li> </ul>"},{"location":"business_domain/","title":"Business Domain","text":"<p>Core business logic implementations using Enterprise JavaBeans (EJBs). These examples demonstrate different EJB types\u2014stateful, stateless, and singleton session beans\u2014for common enterprise patterns like shopping carts, currency conversion, hit counters, web services, and standalone EJB usage.</p>"},{"location":"business_domain/#examples","title":"Examples","text":"<ul> <li>cart - Stateful session bean with shopping cart lifecycle management and <code>@Remove</code> methods</li> <li>converter - Stateless session bean demonstrating currency conversion business logic</li> <li>counter - Singleton session bean with shared state for tracking web page hits</li> <li>helloservice - JAX-WS web service implemented as a stateless session bean</li> <li>standalone - Stateless session bean for standalone EJB container usage</li> </ul>"},{"location":"cargotracker/","title":"CargoTracker","text":"<p>Domain-Driven Design (DDD) cargo shipping tracker demonstrating Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, JSON Binding, Bean Validation, and JMS.</p>"},{"location":"cargotracker/#overview","title":"Overview","text":"<p>CargoTracker showcases end-to-end application architecture with multiple interfaces (web UI, REST API, file scanning) and complex domain modeling including aggregates, repositories, and domain events. This application implements the cargo tracking example from Eric Evans' seminal Domain-Driven Design book.</p>"},{"location":"cargotracker/#key-technologies","title":"Key Technologies","text":"<ul> <li>Jakarta Faces - Web UI layer</li> <li>CDI - Dependency injection</li> <li>Enterprise Beans - Business logic</li> <li>JPA - Data persistence</li> <li>REST - API integration</li> <li>Batch - File processing</li> <li>JSON Binding - Data serialization</li> <li>Bean Validation - Input validation</li> <li>JMS - Asynchronous messaging</li> </ul>"},{"location":"cargotracker/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Domain-Driven Design patterns (Aggregates, Entities, Value Objects)</li> <li>Repository pattern for data access</li> <li>Domain events for decoupled communication</li> <li>Multiple presentation interfaces (Web UI, REST API)</li> <li>Batch processing for file-based imports</li> </ul>"},{"location":"citation/","title":"Citation","text":"BibTeX APA MLA <pre>[Placeholder: BibTeX citation]</pre> Copy"},{"location":"coffee_shop/","title":"Coffee Shop","text":"<p>Microservices architecture with Orders, Barista, and Kitchen services communicating via Apache Kafka.</p>"},{"location":"coffee_shop/#overview","title":"Overview","text":"<p>Coffee Shop demonstrates event-driven microservices architecture with asynchronous inter-service communication and eventual consistency. The application models a coffee shop ordering system with separate services handling orders, beverage preparation, and food preparation.</p>"},{"location":"coffee_shop/#key-technologies","title":"Key Technologies","text":"<ul> <li>MicroProfile Config - External configuration</li> <li>MicroProfile Health - Service health checks</li> <li>MicroProfile OpenAPI - API documentation</li> <li>MicroProfile Metrics - Application monitoring</li> <li>JPA with PostgreSQL - Data persistence</li> <li>JAX-RS - REST API endpoints</li> <li>Apache Kafka - Event streaming</li> <li>Reactive Messaging - Async message handling</li> </ul>"},{"location":"coffee_shop/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Microservices architecture with service decomposition</li> <li>Event-driven communication via Kafka topics</li> <li>Distributed transaction coordination</li> <li>Eventual consistency patterns</li> <li>Service health monitoring and metrics</li> <li>RESTful API design</li> </ul>"},{"location":"daytrader/","title":"DayTrader","text":"<p>Online stock trading benchmark application demonstrating real-world Java EE workload patterns.</p>"},{"location":"daytrader/#overview","title":"Overview","text":"<p>DayTrader is a performance benchmark application that implements a complete online stock trading system. It includes user authentication, portfolio management, stock quote lookup, and buy/sell transaction processing. This application is commonly used for measuring application server performance and scalability.</p>"},{"location":"daytrader/#key-technologies","title":"Key Technologies","text":"<ul> <li>Stateless Session Beans - Business logic tier</li> <li>JPA - Entity persistence</li> <li>Optimistic Locking - Concurrency control</li> <li>Transaction Management - ACID properties</li> <li>Connection Pooling - Resource optimization</li> <li>Web Services - SOAP and REST interfaces</li> </ul>"},{"location":"daytrader/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Performance-oriented design patterns</li> <li>High-concurrency transaction processing</li> <li>Database optimization with connection pooling</li> <li>Optimistic locking for concurrent data access</li> <li>Stateless architecture for horizontal scalability</li> <li>Comprehensive transaction management</li> <li>Multiple interface options (Web, SOAP, REST)</li> </ul>"},{"location":"dependency_injection/","title":"Dependency Injection","text":"<p>CDI and dependency injection patterns including custom qualifiers, interceptors, decorators, producer methods, event observers, and alternative implementations for conditional bean selection.</p>"},{"location":"dependency_injection/#examples","title":"Examples","text":"<ul> <li>billpayment - CDI with <code>@Inject</code>, custom qualifiers, interceptors, and event observers</li> <li>decorators - CDI decorators and interceptors for cross-cutting concerns</li> <li>encoder - CDI with <code>@Alternative</code> implementations for conditional bean selection</li> <li>guessnumber - CDI with custom qualifiers, producer methods, and scope management</li> <li>producerfields - CDI producer fields for EntityManager injection and resource management</li> <li>producermethods - CDI producer methods with custom qualifiers for bean selection</li> <li>simplegreeting - Basic CDI dependency injection with <code>@Inject</code> and custom qualifiers</li> </ul>"},{"location":"infrastructure/","title":"Infrastructure","text":"<p>Enterprise features including managed executors for concurrency, asynchronous EJB methods, interceptors for cross-cutting concerns, and timer services for scheduled task execution.</p>"},{"location":"infrastructure/#examples","title":"Examples","text":"<ul> <li>concurrency-jobs - ManagedExecutorService with <code>@Resource</code> injection for concurrent task execution</li> <li>concurrency-taskcreator - ManagedExecutorService and ManagedScheduledExecutorService for async tasks with WebSocket updates</li> <li>ejb-async - Asynchronous EJB methods with Future return types <li>ejb-interceptor - EJB interceptors for method-level cross-cutting concerns</li> <li>ejb-timersession - EJB timer service with <code>@Schedule</code> and <code>@Timeout</code> for scheduled tasks</li>"},{"location":"installing/","title":"Installing ScarfBench","text":"<p>ScarfBench is a suite of self-contained Java applications intended to be run locally (typically via Docker) for benchmarking and evaluation.</p>"},{"location":"installing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker (Docker Desktop is fine)</li> <li>just (command runner)</li> <li>Git</li> </ul> <p>Optional (only for running local smoke scripts outside containers):</p> <ul> <li>Python 3</li> </ul>"},{"location":"installing/#install-just","title":"Install <code>just</code>","text":"macOS (Homebrew)Other platforms <pre><code>brew install just\n</code></pre> <p>See the upstream install options: https://github.com/casey/just</p>"},{"location":"installing/#get-the-repository","title":"Get the repository","text":"<pre><code>git clone https://github.com/ibm/scarfbench\ncd scarfbench\n</code></pre>"},{"location":"installing/#run-an-application","title":"Run an application","text":"<p>Each benchmark app directory contains a <code>justfile</code> and a <code>Dockerfile</code>.</p> <p>Example:</p> <pre><code>cd business_domain/counter/spring\njust up\n</code></pre> <p>Common commands:</p> <pre><code>just            # list available commands\njust logs       # view logs\njust down       # stop\njust clean      # clean build artifacts\n</code></pre>"},{"location":"installing/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Port already in use: run <code>just down</code>, then retry <code>just up</code>.</li> <li>Docker build issues: try <code>just clean</code> then <code>just up</code>.</li> </ul>"},{"location":"integration/","title":"Integration","text":"<p>Integration technologies featuring Jakarta Batch processing, JMS messaging patterns, message-driven beans, JAX-WS web services, and Java Connector Architecture for enterprise system integration.</p>"},{"location":"integration/#examples","title":"Examples","text":"<ul> <li>batch-phonebilling - Jakarta Batch API with ItemReader, ItemProcessor, ItemWriter, and chunk-oriented processing</li> <li>batch-webserverlog - Jakarta Batch with custom partitioning, checkpointing, and job orchestration</li> <li>connectors-trading - Java Connector Architecture resource adapter for EIS integration</li> <li>connectors-traffic - JCA inbound resource adapter with MessageEndpoint and WorkManager for async messaging</li> <li>jaxws-hello-appclient - JAX-WS web service client using <code>@WebServiceRef</code> in application client container</li> <li>jaxws-hello-webclient - JAX-WS web service client invocation from servlet using Service API</li> <li>jms-clientmdbentity - Message-driven beans with JPA entity persistence and JMS topics</li> <li>jms-clientsessionmdb - Message-driven bean consuming messages from stateless session bean</li> <li>jms-durablesubscription - Durable topic subscriptions with <code>@MessageDriven</code> and ActivationConfig properties</li> <li>jms-simple - JMS producer and consumer using <code>@Resource</code> injection for ConnectionFactory and Queue/Topic</li> <li>jms-simplemessage - Basic JMS message exchange with producer and consumer patterns</li> <li>jms-transactedexample - Transacted JMS sessions with message-driven beans and container-managed transactions</li> <li>jms-websimplemessage - JMS integration with web tier using managed beans for message sending/receiving</li> </ul>"},{"location":"persistence/","title":"Persistence","text":"<p>Data persistence patterns using JPA entities with CRUD operations, complex entity relationships, composite keys, inheritance strategies, and JPQL queries for database interactions.</p>"},{"location":"persistence/#examples","title":"Examples","text":"<ul> <li>address-book - JPA entities with JSF frontend using CRUD operations via EntityManager</li> <li>order - JPA entity relationships with composite keys and join tables</li> <li>roster - JPA inheritance strategies, JPQL queries, and many-to-many relationships</li> </ul>"},{"location":"petclinic/","title":"PetClinic","text":"<p>Full-featured veterinary clinic management system using Jakarta Faces (PrimeFaces) for the UI layer.</p>"},{"location":"petclinic/#overview","title":"Overview","text":"<p>PetClinic is a complete web application for managing a veterinary clinic. It demonstrates CRUD operations with complex entity relationships and provides comprehensive user workflows for managing owners, pets, visits, and veterinarians.</p>"},{"location":"petclinic/#key-technologies","title":"Key Technologies","text":"<ul> <li>Jakarta Faces (PrimeFaces) - Rich UI components</li> <li>JPA - Object-relational mapping</li> <li>CDI - Dependency injection</li> <li>Bean Validation - Input validation</li> <li>JSF Navigation - Page flow control</li> </ul>"},{"location":"petclinic/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>One-to-many relationships (owners-pets)</li> <li>Many-to-one relationships (pets-visits)</li> <li>Many-to-many relationships (vets-specialties)</li> <li>Complex forms with validation</li> <li>Master-detail views</li> <li>CRUD operations for all entities</li> <li>Rich UI components (data tables, dialogs, forms)</li> <li>Complete user workflows for clinic operations</li> </ul>"},{"location":"presentation/","title":"Presentation","text":"<p>Web tier implementations including servlets, JAX-RS REST APIs, WebSocket endpoints, server-sent events, file uploads, filters, listeners, and real-time communication patterns.</p>"},{"location":"presentation/#examples","title":"Examples","text":"<ul> <li>dukeetf - Async servlet with server-sent events for real-time updates</li> <li>dukeetf2 - WebSocket server endpoint for bidirectional real-time communication</li> <li>fileupload - Servlet file upload using <code>@MultipartConfig</code> for multipart/form-data handling</li> <li>hello-servlet - Basic HTTP servlet with request/response handling</li> <li>jaxrs-customer - JAX-RS REST API with CRUD operations, JPA entities, and client invocation</li> <li>jaxrs-hello - Simple JAX-RS resource with <code>@GET</code> and <code>@POST</code> methods</li> <li>jaxrs-rsvp - JAX-RS with JPA entities, <code>@Singleton</code>/<code>@Startup</code> lifecycle, and RESTful CRUD</li> <li>mood - Servlet filters and listeners for request/response processing and lifecycle events</li> <li>websocketbot - WebSocket encoders/decoders with session management for chat application</li> </ul>"},{"location":"quickstart/","title":"Quickstart Guide","text":"<p>This benchmark suite comes with most things needed to run the benchmark applications. Everything is already set up!</p>"},{"location":"quickstart/#whats-included","title":"What's Included","text":"<p>Each application comes with:</p> <ul> <li>Dockerfile - Pre-configured container with all dependencies installed</li> <li>justfile - Simple commands to build and run everything</li> <li>smoke.py or smoke/ - Automated tests to verify the application works</li> </ul> <p>You don't need to install Maven, Java, or any dependencies. Docker handles it all!</p>"},{"location":"quickstart/#prerequisites","title":"Prerequisites","text":"<p>You only need:</p> <ul> <li>Docker installed on your machine</li> <li>Just command runner (you can install it via Cargo or your package manager)</li> </ul>"},{"location":"quickstart/#running-an-application","title":"Running an Application","text":""},{"location":"quickstart/#step-1-pick-an-application","title":"Step 1: Pick an Application","text":"<p>Browse the directory structure and choose any application. For example:</p> <pre><code>business_domain/counter/spring/\ndependency_injection/encoder/jakarta/\npresentation/mood/quarkus/\n</code></pre>"},{"location":"quickstart/#step-2-navigate-to-the-application","title":"Step 2: Navigate to the Application","text":"<pre><code>cd business_domain/counter/spring\n</code></pre>"},{"location":"quickstart/#step-3-run-it","title":"Step 3: Run It!","text":"<pre><code>just up\n</code></pre> <p>That's it! The <code>just up</code> command will: 1. Build your application 2. Build the Docker container 3. Start everything up</p>"},{"location":"quickstart/#step-4-check-the-logs","title":"Step 4: Check the Logs","text":"<pre><code>just logs\n</code></pre>"},{"location":"quickstart/#step-5-stop-when-done","title":"Step 5: Stop When Done","text":"<pre><code>just down\n</code></pre>"},{"location":"quickstart/#common-commands","title":"Common Commands","text":"<p>Every application supports these commands (via the <code>justfile</code>):</p> Command What it does <code>just</code> Shows all available commands <code>just up</code> Builds and starts the application <code>just down</code> Stops the application <code>just logs</code> Shows application logs <code>just build</code> Builds the application (Maven) <code>just docker-build</code> Builds the Docker image <code>just clean</code> Removes build artifacts"},{"location":"quickstart/#running-smoke-tests","title":"Running Smoke Tests","text":"<p>Most applications include automated tests. To run them:</p> <pre><code># If smoke.py exists\npython3 smoke.py\n\n# If smoke/ folder exists\ncd smoke &amp;&amp; ./verify-all.sh\n</code></pre>"},{"location":"quickstart/#example-walkthrough","title":"Example Walkthrough","text":"<p>Let's run the counter application:</p> <pre><code># 1. Go to the application\ncd business_domain/counter/spring\n\n# 2. Start it up\njust up\n\n# 3. Wait a few seconds, then check logs\njust logs\n\n# 4. Open your browser to http://localhost:8080\n\n# 5. When done, stop it\njust down\n</code></pre>"},{"location":"quickstart/#framework-variations","title":"Framework Variations","text":"<p>Each application type comes in three flavors:</p> <ul> <li>jakarta/ - Jakarta EE (enterprise Java)</li> <li>quarkus/ - Quarkus (cloud-native Java)</li> <li>spring/ - Spring Boot (popular Java framework)</li> </ul> <p>Pick whichever framework you want to test!</p>"},{"location":"quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>Port already in use? <pre><code>just down\n# Wait a few seconds\njust up\n</code></pre></p> <p>Want to rebuild from scratch? <pre><code>just clean\njust docker-build\njust up\n</code></pre></p> <p>Need to see what's happening? <pre><code>just logs\n</code></pre></p>"},{"location":"quickstart/#quick-reference","title":"Quick Reference","text":"<pre><code># See all commands\njust\n\n# Full workflow: build + start\njust up\n\n# Check if it's working\njust logs\n\n# Stop everything\njust down\n</code></pre>"},{"location":"realworld/","title":"RealWorld","text":"<p>Medium.com clone (Conduit) implementing the RealWorld specification with full CRUD operations, JWT authentication, article management, comments, favorites, tags, and user following.</p>"},{"location":"realworld/#overview","title":"Overview","text":"<p>RealWorld is a Medium.com clone that adheres to the RealWorld specification, providing a standardized way to build and compare fullstack applications. It includes comprehensive features for article publishing, user interactions, and social features.</p>"},{"location":"realworld/#key-technologies","title":"Key Technologies","text":"<ul> <li>MicroProfile JWT - Token-based authentication</li> <li>JAX-RS - RESTful API design</li> <li>JPA with PostgreSQL - Data persistence</li> <li>BCrypt - Password hashing</li> <li>Testcontainers - Integration testing</li> <li>MicroShed Testing - Testing framework</li> </ul>"},{"location":"realworld/#architecture-highlights","title":"Architecture Highlights","text":"<ul> <li>Complete RESTful API implementation</li> <li>JWT-based authentication and authorization</li> <li>Article CRUD with slug generation</li> <li>Comment system on articles</li> <li>User favorites and following</li> <li>Tag-based article categorization</li> <li>Pagination and filtering</li> <li>Comprehensive exception handling</li> <li>Integration tests with real database (Testcontainers)</li> <li>Secure password storage with BCrypt</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>[Placeholder: Resources content]</p>"},{"location":"security/","title":"Security","text":"<p>Authentication and authorization patterns featuring Jakarta Security identity stores, form-based and basic authentication, EJB security, role-based access control, and password hashing.</p>"},{"location":"security/#examples","title":"Examples","text":"<ul> <li>built-in-db-identity-store - Jakarta Security <code>@DatabaseIdentityStoreDefinition</code> with Pbkdf2PasswordHash</li> <li>custom-identity-store - Custom IdentityStore implementation with <code>@ApplicationScoped</code> CDI bean</li> <li>security-cart-secure - EJB security with <code>@DeclareRoles</code> and <code>@RolesAllowed</code> annotations</li> <li>security-converter-secure - Servlet-based security with declarative role-based access control</li> <li>security-hello1-formauth - Form-based authentication with <code>@FormAuthenticationMechanismDefinition</code></li> <li>security-hello2-basicauth - HTTP Basic authentication with <code>@BasicAuthenticationMechanismDefinition</code></li> </ul>"},{"location":"whole_applications/","title":"Whole Applications","text":"<p>Complete, production-grade application examples demonstrating the coordination and integration of multiple Java EE layers and technologies.</p>"},{"location":"whole_applications/#examples","title":"Examples","text":"<ul> <li> <p>cargotracker - Domain-Driven Design (DDD) cargo shipping tracker demonstrating Jakarta Faces, CDI, Enterprise Beans, JPA, REST, Batch, JSON Binding, Bean Validation, and JMS. Showcases end-to-end application architecture with multiple interfaces (web UI, REST API, file scanning) and complex domain modeling including aggregates, repositories, and domain events. Implements the cargo tracking example from Eric Evans' DDD book.</p> </li> <li> <p>coffee-shop - Microservices architecture with Orders, Barista, and Kitchen services communicating via Apache Kafka. Demonstrates MicroProfile (Config, Health, OpenAPI, Metrics), JPA with PostgreSQL, JAX-RS REST APIs, reactive messaging patterns, and distributed transaction coordination. Shows event-driven architecture with asynchronous inter-service communication and eventual consistency.</p> </li> <li> <p>daytrader - Online stock trading benchmark application demonstrating real-world Java EE workload patterns. Implements user authentication, portfolio management, stock quote lookup, and buy/sell transactions. Showcases performance-oriented design with stateless session beans, JPA entities with optimistic locking, transaction management, connection pooling, and web service interfaces. Used for measuring application server performance.</p> </li> <li> <p>petclinic - Full-featured veterinary clinic management system using Jakarta Faces (PrimeFaces) for the UI layer. Demonstrates CRUD operations with JPA entities showing one-to-many, many-to-one, and many-to-many relationships (owners-pets, pets-visits, vets-specialties). Includes CDI beans, Bean Validation, JSF navigation, complex forms, and master-detail views. Complete web application with user workflows for managing owners, pets, visits, and veterinarians.</p> </li> <li> <p>realworld - Medium.com clone (Conduit) implementing the RealWorld specification with full CRUD operations, JWT authentication, article management, comments, favorites, tags, and user following. Demonstrates MicroProfile JWT, JAX-RS REST API design, JPA with PostgreSQL, password hashing (BCrypt), slug generation, pagination, filtering, and comprehensive exception handling. Includes integration tests with Testcontainers and MicroShed testing framework.</p> </li> </ul>"},{"location":"core-concepts/","title":"Core Concepts","text":"<p>To be updated.</p>"},{"location":"reference/python-api/","title":"API Reference","text":""},{"location":"reference/python-api/#overview","title":"Overview","text":"<p>Browse the CLDK API reference. Use the links below to view package-specific documentation.</p>"},{"location":"reference/python-api/#core","title":"Core","text":"<p>Fundamental building blocks of CLDK. See the Core API.</p>"},{"location":"reference/python-api/#java","title":"Java","text":"<p>Program analysis for Java and related data models. See the Java API.</p>"},{"location":"reference/python-api/#python","title":"Python","text":"<p>Program analysis for Python and related data models. See the Python API.</p>"},{"location":"reference/python-api/#cc","title":"C/C++","text":"<p>Program analysis for C/C++ and related data models. See the C/C++ API.</p>"},{"location":"reference/python-api/c-cpp/","title":"C/C++ API","text":"<p>This page documents the C and C++ related APIs in the CLDK library.</p> <p>Use the table of contents to navigate classes, functions, and submodules exposed under the C/C++ analysis and schema packages.</p>"},{"location":"reference/python-api/c-cpp/#analysis","title":"Analysis","text":"<p>C/C++ analysis utilities and workflows.</p> <p>::: cldk.analysis.c.c_analysis</p>"},{"location":"reference/python-api/c-cpp/#schema","title":"Schema","text":"<p>Data models used by the C/C++ analyzers.</p> <p>::: cldk.models.c.models</p>"},{"location":"reference/python-api/core/","title":"Core API","text":"<p>::: cldk.core</p>"},{"location":"reference/python-api/java/","title":"Java API","text":""},{"location":"reference/python-api/java/#analysis","title":"Analysis","text":"<p>::: cldk.analysis.java.java_analysis</p>"},{"location":"reference/python-api/java/#schema","title":"Schema","text":"<p>::: cldk.models.java.models</p>"},{"location":"reference/python-api/python/","title":"Python API","text":"<p>This page documents the Python-related APIs in the CLDK library.</p> <p>Use the table of contents to navigate classes, functions, and submodules exposed under the Python analysis and schema packages.</p>"},{"location":"reference/python-api/python/#analysis","title":"Analysis","text":"<p>Python analysis utilities and workflows.</p> <p>::: cldk.analysis.python.python_analysis</p>"},{"location":"reference/python-api/python/#schema","title":"Schema","text":"<p>Data models used by the Python analyzers.</p> <p>::: cldk.models.python.models</p>"},{"location":"reference/ts-api/","title":"Typescript API Reference","text":""},{"location":"reference/ts-api/#overview","title":"Overview","text":"<p>Browse the CLDK's Typescript API reference. Use the links below to view package-specific documentation.</p> <p>(work in progress, please checkback later or email authors)</p>"}]}